% layout 'wrapper';
<div class="span8">

<h1 id="T2JqZWN0cw"><a name="T2JqZWN0cw"></a>Objects</h1>

<p>When you design a program, you have to approach it from many levels. At the bottom, you have specific details about the problem you&#39;re solving. At the top levels, you have to organize the code so it makes sense. Our only hope to manage this complexity is to exploit abstraction (treating similar things similarly) and encapsulation (grouping related details together).</p>

<p id="T081"> <a name="b2JqZWN0cw1"></a> <a name="T087Y2xhc3Nlcw1"></a> <a name="Y2xhc3Nlcw1"></a>Functions alone are insufficient for large problems. Several techniques group functions into units of related behaviors. One popular technique is <em>object orientation</em> (OO), or <em>object oriented programming</em> (OOP), where programs work with <em>objects</em>—discrete, unique entities with their own identities.</p>

<h2 id="bW9vc2U"><a name="TW9vc2U"></a>Moose</h2>

<p id="bW9vc2U"><a name="bW9vc2U1"></a>Perl&#39;s default object system is but minimal but flexible. Its syntax is a little clunky, and it exposes <em>how</em> an object system works. You can build great things on top of it, but you or someone else will have to build a lot of code to get what some other languages provide for free.</p>

<p><em>Moose</em> is a complete object system for Perl. It&#39;s a complete distribution available from the CPAN—not a part of the core language, but worth installing and using regardless. Moose offers both a simpler way to use an object system as well as advanced features of languages such as Smalltalk and Common Lisp.</p>

<p>Moose objects work with plain vanilla Perl. Within your programs, you can mix and match objects written with Perl&#39;s default object system and Moose. Of course, you have to write a lot more code to get what Moose provides for you.</p>

<div class="tip">
<p class="title">Moose Documentation</p>
<p>See <code>Moose::Manual</code> on the CPAN for comprehensive Moose documentation.</p>

</div><h3 id="Q2xhc3Nlcw"><a name="Q2xhc3Nlcw"></a>Classes</h3>

<p id="Q1BBTjtNb29zZQ1"> <a name="Q1BBTjtNb29zZTo6TWFudWFs1"></a><a name="Y2xhc3Nlcw2"></a> <a name="YnVpbHRpbnM7cGFja2FnZQ3"></a>A Moose object is a concrete instance of a <em>class</em>, which is a template describing data and behavior specific to the object. A class generally belongs to a package (<a href="03-perl-language.html#cGFja2FnZXM">Packages</a>), which provides its name:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;
    }</code></pre>

</div>

<p id="T087aW5zdGFuY2Vz1">This <code>Cat</code> class <em>appears</em> to do nothing, but that&#39;s all Moose needs to make a class. Create objects (or <em>instances</em>) of the <code>Cat</code> class with the syntax:</p>

<div class="programlisting">

<pre><code>    my $brad = Cat-&gt;new;
    my $jack = Cat-&gt;new;</code></pre>

</div>

<p>Just as an arrow dereferences a reference, this arrow calls a method on <code>Cat</code>.</p>

<h3 id="TWV0aG9kcw"><a name="TWV0aG9kcw"></a>Methods</h3>

<p id="T087bWV0aG9kcw1"> <a name="T087aW52b2NhbnRz1"></a>A <em>method</em> is a function associated with a class. A function may belong to a namespace; you&#39;ve seen that. Similarly, a method belongs to a class.</p>

<p>When you call a method, you do so with an <em>invocant</em>. When you call <code>new()</code> on <code>Cat</code>, the name of the class, <code>Cat</code>, is <code>new()</code>&#39;s invocant. Think of this as sending a message to a class: &quot;do whatever <code>new()</code> does.&quot; In this case, sending the <code>new</code> message—calling the <code>new()</code> method—returns a new object of the <code>Cat</code> class.</p>

<p>When you call a method on an object, that object is the invocant:</p>

<div class="programlisting">

<pre><code>    my $choco = <strong>Cat</strong>-&gt;new;
    <strong>$choco</strong>-&gt;sleep_on_keyboard;</code></pre>

</div>

<p>A method&#39;s first argument is its invocant (<code>$self</code>, by convention). Suppose a <code>Cat</code> can <code>meow()</code>:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        <strong>sub meow</strong>
        <strong>{</strong>
            <strong>my $self = shift;</strong>
            <strong>say &#39;Meow!&#39;;</strong>
        <strong>}</strong>
    }</code></pre>

</div>

<p>Now any <code>Cat</code> instance can wake you up in the morning because it hasn&#39;t eaten yet:</p>

<div class="programlisting">

<pre><code>    # the cat always meows three times at 6 am
    my $fuzzy_alarm = Cat-&gt;new;
    $fuzzy_alarm-&gt;meow for 1 .. 3;</code></pre>

</div>

<p id="Y2xhc3NtZXRob2Q1"> <a name="aW5zdGFuY2VtZXRob2Q1"></a> <a name="T087Y2xhc3NtZXRob2Rz1"></a> <a name="T087aW5zdGFuY2VtZXRob2Rz1"></a> <a name="bWV0aG9kcztjbGFzcw1"></a> <a name="bWV0aG9kcztpbnN0YW5jZQ1"></a>Every object can have its own distinct data. (More on this briefly.) Methods which read or write the data of their invocants are <em>instance methods</em>; they depend on the presence of an appropriate invocant to work correctly. Methods (such as <code>meow()</code>) which do not access instance data are <em>class methods</em>. You may invoke class methods on classes and class and instance methods on instances, but you cannot invoke instance methods on classes.</p>

<p id="bWV0aG9kcztjb25zdHJ1Y3Rvcg1"><em>Constructors</em>, which <em>create</em> instances, are obviously class methods. Moose provides a default constructor for you, named <code>new()</code>. That&#39;s why you can create a <code>Cat</code> object with the minimal class declaration earlier.</p>

<p>Class methods are effectively namespaced global functions. Without access to instance data, they have few advantages over namespaced functions. Most OO code uses instance methods to read and write instance data.</p>

<h3 id="QXR0cmlidXRlcw"><a name="QXR0cmlidXRlcw"></a>Attributes</h3>

<p id="YXR0cmlidXRlcztvYmplY3Rz1"> <a name="T087YXR0cmlidXRlcw1"></a> <a name="T087c3RhdGU1"></a> <a name="YXR0cmlidXRlczt0eXBlZA1"></a> <a name="YXR0cmlidXRlcztybyhyZWFkb25seSk1"></a>Every Perl object is unique. Objects can contain private data associated with each unique object—you may hear this data called <em>attributes</em>, <em>instance data</em>, or object <em>state</em>. Define an attribute by declaring it as part of the class:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        <strong>has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;</strong>
    }</code></pre>

</div>

<p>Moose exports the <code>has()</code> function for you to use to declare an attribute. In English, this code reads &quot;<code>Cat</code> objects have a <code>name</code> attribute. It&#39;s read-only, and is a string.&quot; The first argument, <code>&#39;name&#39;</code>, is the attribute&#39;s name. The <code>is =&gt; &#39;ro&#39;</code> pair of arguments declares that this attribute is <code>r</code>ead <code>o</code>nly, so you cannot modify the attribute&#39;s value after you&#39;ve set it. Finally, the <code>isa =&gt; &#39;Str&#39;</code> pair declares that the value of this attribute can only be a <code>str</code>ing.</p>

<p id="bWV0aG9kczthY2Nlc3Nvcg1"> <a name="T087YWNjZXNzb3JtZXRob2Rz1"></a>In this example, Moose creates an <em>accessor</em> method named <code>name()</code> and allows you to pass a <code>name</code> parameter to <code>Cat</code>&#39;s constructor:</p>

<div class="programlisting">

<pre><code>    for my $name (qw( Tuxie Petunia Daisy ))
    {
        my $cat = Cat-&gt;new( name =&gt; $name );
        say &quot;Created a cat for &quot;, $cat-&gt;name;
    }</code></pre>

</div>

<div class="sidebar">

<p>Moose&#39;s documentation uses parentheses to separate attribute names and characteristics:</p>

<div class="programlisting">

<pre><code>        has &#39;name&#39; =&gt; ( is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39; );</code></pre>

</div>

<p>This is equivalent to:</p>

<div class="programlisting">

<pre><code>    has( &#39;name&#39;, &#39;is&#39;, &#39;ro&#39;, &#39;isa&#39;, &#39;Str&#39; );</code></pre>

</div>

<p>Moose&#39;s approach works nicely for complex declarations:</p>

<div class="programlisting">

<pre><code>    has &#39;name&#39; =&gt; (
        is         =&gt; &#39;ro&#39;,
        isa        =&gt; &#39;Str&#39;,

        # advanced Moose options; perldoc Moose
        init_arg   =&gt; undef,
        lazy_build =&gt; 1,
    );</code></pre>

</div>

<p>... while this book prefers a low-punctuation approach for simple declarations. Choose the style which offers you the most clarity.</p>

</div>

<p id="YXR0cmlidXRlczt1bnR5cGVk1">Moose will complain if you try to set <code>name</code> to a value which isn&#39;t a string. Attributes do not <em>need</em> to have types. In that case, anything goes:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        <strong>has &#39;age&#39;,  is =&gt; &#39;ro&#39;;</strong>
    }

    my $invalid = Cat-&gt;new( name =&gt; &#39;bizarre&#39;,
                            age  =&gt; &#39;purple&#39; );</code></pre>

</div>

<p>If you add a type to your attribute declaration, Moose will attempt to validate the values assigned to that attribute. Sometimes this strictness is invaluable.</p>

<p id="YXR0cmlidXRlcztydyhyZWFkLXdyaXRlKQ1"> <a name="bWV0aG9kczttdXRhdG9y1"></a> <a name="T087bXV0YXRvcm1ldGhvZHM1"></a>If you mark an attribute as readable <em>and</em> writable (with <code>is =&gt; rw</code>), Moose will create a <em>mutator</em> method which can change that attribute&#39;s value:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;age&#39;,  is =&gt; &#39;ro&#39;, isa =&gt; &#39;Int&#39;;
        <strong>has &#39;diet&#39;, is =&gt; &#39;rw&#39;;</strong>
    }

    my $fat = Cat-&gt;new( name =&gt; &#39;Fatty&#39;,
                        age  =&gt; 8,
                        diet =&gt; &#39;Sea Treats&#39; );

    say $fat-&gt;name, &#39; eats &#39;, $fat-&gt;diet;

    <strong>$fat-&gt;diet( &#39;Low Sodium Kitty Lo Mein&#39; );</strong>
    say $fat-&gt;name, &#39; now eats &#39;, $fat-&gt;diet;</code></pre>

</div>

<p>An <code>ro</code> accessor used as a mutator will throw the exception <code>Cannot assign a value to a read-only accessor at ...</code>.</p>

<p>Using <code>ro</code> or <code>rw</code> is a matter of design, convenience, and purity. Moose enforces no particular philosophy here. Some people suggest making all instance data <code>ro</code> such that you must pass instance data into the constructor (<a href="07-object-oriented-perl.html#aW1tdXRhYmlsaXR5">Immutability</a>). In the <code>Cat</code> example, <code>age()</code> might still be an accessor, but the constructor could take the <em>year</em> of the cat&#39;s birth and calculate the age itself based on the current year. This approach consolidates validation code and ensure that all created objects have valid data.</p>

<p>Instance data shows some of the value of object orientation. An object contains related data and can perform behaviors with that data. A class describes that data and those behaviors. You can have multiple independent objects with separate instance data and treat all of those objects the same way; they will behave differently depending on their instance data.</p>

<h3 id="RW5jYXBzdWxhdGlvbg"><a name="RW5jYXBzdWxhdGlvbg"></a>Encapsulation</h3>

<p id="ZW5jYXBzdWxhdGlvbg2"> <a name="T087ZW5jYXBzdWxhdGlvbg1"></a>Moose allows you to declare <em>which</em> attributes class instances possess (a cat has a name) as well as the attributes of those attributes (you cannot change a cat&#39;s name; you can only read it). Moose itself decides how to <em>store</em> those attributes. You can change that if you like, but allowing Moose to manage your storage encourages <em>encapsulation</em>: hiding the internal details of an object from external users of that object.</p>

<p>Consider a change to how <code>Cat</code>s manage their ages. Instead of passing a value for an age to the constructor, pass in the year of the cat&#39;s birth and calculate the age as needed:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;,        is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;,        is =&gt; &#39;rw&#39;;
        <strong>has &#39;birth_year&#39;,  is =&gt; &#39;ro&#39;, isa =&gt; &#39;Int&#39;;</strong>

        <strong>sub age</strong>
        <strong>{</strong>
            <strong>my $self = shift;</strong>
            <strong>my $year = (localtime)[5] + 1900;</strong>

            <strong>return $year - $self-&gt;birth_year;</strong>
        <strong>}</strong>
    }</code></pre>

</div>

<p>While the syntax for <em>creating</em> <code>Cat</code> objects has changed, the syntax for <em>using</em> <code>Cat</code> objects has not. Outside of <code>Cat</code>, <code>age()</code> behaves as it always has. <em>How</em> it works is a detail hidden inside the <code>Cat</code> class.</p>

<div class="tip">
<p class="title">Compatibility and APIs</p>
<p>Retain the old syntax for <em>creating</em> <code>Cat</code> objects by customizing the generated <code>Cat</code> constructor to allow passing an <code>age</code> parameter. Calculate <code>birth_year</code> from that. See <code>perldoc Moose::Manual::Attributes</code>.</p>

</div><p id="YXR0cmlidXRlcztkZWZhdWx0dmFsdWVz1">Calculating ages has another advantage. A <em>default attribute value</em> will do the right thing when someone creates a new <code>Cat</code> object without passing a birth year:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;, isa =&gt; &#39;Str&#39;;

        <strong>has &#39;birth_year&#39;,</strong>
            <strong>is      =&gt; &#39;ro&#39;,</strong>
            <strong>isa     =&gt; &#39;Int&#39;,</strong>
            <strong>default =&gt; sub { (localtime)[5] + 1900 };</strong>
    }</code></pre>

</div>

<p>The <code>default</code> keyword on an attribute takes a function reference <span class="footnote">You can use a simple value such as a number or string directly, but use a function reference for anything more complex.</span> which returns the default value for that attribute when constructing a new object. If the code creating an object passes no constructor value for that attribute, the object gets the default value:</p>

<div class="programlisting">

<pre><code>    my $kitten = Cat-&gt;new( name =&gt; &#39;Choco&#39; );</code></pre>

</div>

<p>... and that kitten will have an age of <code>0</code> until next year.</p>

<h4 id="UG9seW1vcnBoaXNt"><a name="UG9seW1vcnBoaXNt"></a>Polymorphism</h4>

<p>Encapsulation is useful, but the real power of object orientation is much broader. A well-designed OO program can manage many types of data. When well-designed classes encapsulate specific details of objects into the appropriate places, something curious happens: the code often becomes <em>less</em> specific.</p>

<p>Moving the details of what the program knows about individual <code>Cat</code>s (the attributes) and what the program knows that <code>Cat</code>s can do (the methods) into the <code>Cat</code> class means that code that deals with <code>Cat</code> instances can happily ignore <em>how</em> <code>Cat</code> does what it does.</p>

<p>Consider a function which displays details of an object:</p>

<div class="programlisting">

<pre><code>    sub show_vital_stats
    {
        my $object = shift;

        say &#39;My name is &#39;, $object-&gt;name;
        say &#39;I am &#39;,       $object-&gt;age;
        say &#39;I eat &#39;,      $object-&gt;diet;
    }</code></pre>

</div>

<p id="Z2VuZXJpY2l0eQ1"> <a name="T087Z2VuZXJpY2l0eQ1"></a>It&#39;s obvious (in context) that this function works if you pass it a <code>Cat</code> object. It&#39;s less obvious that it will do the right thing for <em>any</em> object with the appropriate three accessors, no matter <em>how</em> that object provides those accessors and no matter <em>what kind</em> of object it is: <code>Cat</code>, <code>Caterpillar</code>, or <code>Catbird</code>. <code>show_vital_stats()</code> cares that an invocant is valid only in that it supports three methods, <code>name()</code>, <code>age()</code>, and <code>diet()</code> which take no arguments and each return something which can concatenate in a string context. You may have a hundred different classes in your code, none of which have any obvious relationships, but they will work with this function if they conform to this expected behavior.</p>

<p id="cG9seW1vcnBoaXNt1"> <a name="T087cG9seW1vcnBoaXNt1"></a>This property is called <em>polymorphism</em>. It means that you can substitute an object of one class for an object of another class if they provide the same external interface.</p>

<div class="tip">
<p class="title">Duck Typing</p>
<p id="ZHVja3R5cGluZw1"> <a name="T087ZHVja3R5cGluZw1"></a></p>

<p>Some languages and environments require you to declare (or at least imply) a formal relationship between two classes before allowing a program to substitute instances for each other. Perl provides ways to enforce these checks, but it does not require them. Its default ad-hoc system lets you treat any two instances with methods of the same name as equivalent. Some people call this <em>duck typing</em>, arguing that any object which can <code>quack()</code> is sufficiently duck-like that you can treat it as a duck.</p>

</div><p>Consider how you might enumerate a zoo&#39;s worth of animals without this polymorphic function. The benefit of genericity should be obvious. As well, any specific details about how to calculate the age of an ocelot or octopus can belong in the relevant class—where it matters most.</p>

<p>Of course, the mere existence of a method called <code>name()</code> or <code>age()</code> does not by itself imply the behavior of that object. A <code>Dog</code> object may have an <code>age()</code> which is an accessor such that you can discover <code>$rodney</code> is 11 but <code>$lucky</code> is 6. A <code>Cheese</code> object may have an <code>age()</code> method that lets you control how long to stow <code>$cheddar</code> to sharpen it. <code>age()</code> may be an accessor in one class but not in another:</p>

<div class="programlisting">

<pre><code>    # how old is the cat?
    my $years = $zeppie-&gt;age;

    # store the cheese in the warehouse for six months
    $cheese-&gt;age;</code></pre>

</div>

<p>Sometimes it&#39;s useful to know <em>what</em> an object does and what that <em>means</em>.</p>

<h3 id="cm9sZXM"><a name="Um9sZXM"></a>Roles</h3>

<p id="cm9sZXM"> <a name="cm9sZXM1"></a>A <em>role</em> is a named collection of behavior and state <span class="footnote">See the P6 design documents on roles at <a class="url" href="http://feather.perl6.nl/syn/S14.html">http://feather.perl6.nl/syn/S14.html</a> and research on Smalltalk traits at <a class="url" href="http://scg.unibe.ch/research/traits">http://scg.unibe.ch/research/traits</a> for copious details.</span>. While a class organizes behaviors and state into a template for objects, a role organizes a named collection of behaviors and state. You can instantiate a class, but not a role. A role is something a class <em>does</em>.</p>

<p>Given an <code>Animal</code> which has an age and a <code>Cheese</code> which can age, one difference may be that <code>Animal</code> does the <code>LivingBeing</code> role, while the <code>Cheese</code> does the <code>Storable</code> role:</p>

<div class="programlisting">

<pre><code>    package LivingBeing
    {
        use Moose::Role;

        requires qw( name age diet );
    }</code></pre>

</div>

<p>The <code>requires</code> keyword provided by <code>Moose::Role</code> allows you to list methods that this role needs from its composing classes. In other words, anything which does this role must supply the <code>name()</code>, <code>age()</code>, and <code>diet()</code> methods. The <code>Cat</code> class must explicitly mark that it performs the role:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;, isa =&gt; &#39;Str&#39;;

        has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        <strong>with &#39;LivingBeing&#39;;</strong>

        sub age { ... }
    }</code></pre>

</div>

<p id="cm9sZXM7Y29tcG9zaXRpb241">The <code>with</code> line causes Moose to <em>compose</em> the <code>LivingBeing</code> role into the <code>Cat</code> class. Composition ensures all of the attributes and methods of the role are part of the class. <code>LivingBeing</code> requires any composing class to provide methods named <code>name()</code>, <code>age()</code>, and <code>diet()</code>. <code>Cat</code> satisfies these constraints. If <code>LivingBeing</code> were composed into a class which did not provide those methods, Moose would throw an exception.</p>

<div class="tip">
<p class="title">Order Matters!</p>
<p>The <code>with</code> keyword used to apply roles to a class must occur <em>after</em> attribute declaration so that composition can identify any generated accessor methods.</p>

</div><p>Now all <code>Cat</code> instances will return a true value when queried if they provide the <code>LivingBeing</code> role. <code>Cheese</code> objects should not:</p>

<div class="programlisting">

<pre><code>    say &#39;Alive!&#39; if $fluffy-&gt;DOES(&#39;LivingBeing&#39;);
    say &#39;Moldy!&#39; if $cheese-&gt;DOES(&#39;LivingBeing&#39;);</code></pre>

</div>

<p>This design technique separates the <em>capabilities</em> of classes and objects from the <em>implementation</em> of those classes and objects. The birth year calculation behavior of the <code>Cat</code> class could itself be a role:</p>

<div class="programlisting">

<pre><code>    package CalculateAge::From::BirthYear
    {
        use Moose::Role;

        has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        sub age
        {
            my $self = shift;
            my $year = (localtime)[5] + 1900;

            return $year - $self-&gt;birth_year;
        }
    }</code></pre>

</div>

<p>Extracting this role from <code>Cat</code> makes the useful behavior available to other classes. Now <code>Cat</code> can compose both roles:</p>

<div class="programlisting">

<pre><code>    package Cat
    {
        use Moose;

        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;;

        <strong>with &#39;LivingBeing&#39;,</strong>
             <strong>&#39;CalculateAge::From::BirthYear&#39;;</strong>
    }</code></pre>

</div>

<p>Notice how the <code>age()</code> method of <code>CalculateAge::From::BirthYear</code> satisfies the requirement of the <code>LivingBeing</code> role. Notice also that any check that <code>Cat</code> performs <code>LivingBeing</code> returns a true value. Extracting <code>age()</code> into a role has only changed the details of <em>how</em> <code>Cat</code> calculates an age. It&#39;s still a <code>LivingBeing</code>. <code>Cat</code> can choose to implement its own age or get it from somewhere else. All that matters is that it provides an <code>age()</code> which satisfies the <code>LivingBeing</code> constraint.</p>

<p id="YWxsb21vcnBoaXNt1"> <a name="cm9sZXM7YWxsb21vcnBoaXNt1"></a>Remember how polymorphism means that you can treat multiple objects with the same behavior in the same way? An object may implement the same behavior in multiple ways. This is <em>allomorphism</em>. Pervasive allomorphism can reduce the size of your classes and increase the code shared between them. It also allows you to name specific and discrete collections of behaviors—very useful for testing for capabilities instead of implementations.</p>

<p id="T087bWl4aW5z1"> <a name="T087bXVsdGlwbGVpbmhlcml0YW5jZQ1"></a> <a name="T087bW9ua2V5cGF0Y2hpbmc1"></a>To compare roles to other design techniques such as mixins, multiple inheritance, and monkeypatching, see <a class="url" href="http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html">http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html</a>.</p>

<h4 id="Um9sZXNhbmRET0VTKCk"><a name="Um9sZXNhbmRET0VTKCk"></a>Roles and DOES()</h4>

<p id="RE9FUygp1"> <a name="TW9vc2U7RE9FUygp1"></a>When you compose a role into a class, the class and its instances will return a true value when you call <code>DOES()</code> on them:</p>

<div class="programlisting">

<pre><code>    say &#39;This Cat is alive!&#39;
        if $kitten-&gt;DOES( &#39;LivingBeing&#39; );</code></pre>

</div>

<h3 id="aW5oZXJpdGFuY2U"><a name="SW5oZXJpdGFuY2U"></a>Inheritance</h3>

<p id="aW5oZXJpdGFuY2U"><a name="aW5oZXJpdGFuY2U1"></a> <a name="T087aW5oZXJpdGFuY2U1"></a> <a name="TW9vc2U7aW5oZXJpdGFuY2U1"></a>Perl&#39;s object system supports <em>inheritance</em>, which establishes a parent and child relationship between two classes such that one specializes the other. The child class behaves the same way as its parent—it has the same number and types of attributes and can use the same methods. It may have additional data and behavior, but you may substitute any instance of a child where code expects its parent. In one sense, a subclass provides the role implied by the existence of its parent class.</p>

<div class="tip">
<p class="title">Roles versus Inheritance</p>
<p>Should you use roles or inheritance? Roles provide composition-time safety, better type checking, better factoring of code, and finer-grained control over names and behaviors, but inheritance is more familiar to experienced developers of other languages. Use inheritance when one class truly <em>extends</em> another. Use a role when a class needs additional behavior, and when you can give that behavior a meaningful name.</p>

</div><p>Consider a <code>LightSource</code> class which provides two public attributes (<code>enabled</code> and <code>candle_power</code>) and two methods (<code>light</code> and <code>extinguish</code>):</p>

<div class="programlisting">

<pre><code>    package LightSource
    {
        use Moose;

        has &#39;candle_power&#39;, is      =&gt; &#39;ro&#39;,
                            isa     =&gt; &#39;Int&#39;,
                            default =&gt; 1;

        has &#39;enabled&#39;, is      =&gt; &#39;ro&#39;,
                       isa     =&gt; &#39;Bool&#39;,
                       default =&gt; 0,
                       writer  =&gt; &#39;_set_enabled&#39;;

        sub light
        {
            my $self = shift;
            $self-&gt;_set_enabled( 1 );
        }

        sub extinguish
        {
            my $self = shift;
            $self-&gt;_set_enabled( 0 );
        }
    }</code></pre>

</div>

<p>(Note that <code>enabled</code>&#39;s <code>writer</code> option creates a private accessor usable within the class to set the value.)</p>

<h4 id="SW5oZXJpdGFuY2VhbmRBdHRyaWJ1dGVz"><a name="SW5oZXJpdGFuY2VhbmRBdHRyaWJ1dGVz"></a>Inheritance and Attributes</h4>

<p>A subclass of <code>LightSource</code> could define an industrial-strength super candle which provides a hundred times the amount of light:</p>

<div class="programlisting">

<pre><code>    package SuperCandle
    {
        use Moose;

        <strong>extends &#39;LightSource&#39;</strong>;

        has &#39;<strong>+</strong>candle_power&#39;, default =&gt; 100;
    }</code></pre>

</div>

<p id="TW9vc2U7ZXh0ZW5kcw1"><code>extends</code> takes a list of class names to use as parents of the current class. If that were the only line in this class, <code>SuperCandle</code> objects would behave in the same ways as <code>LightSource</code> objects. A <code>SuperCandle</code> instance would have both the <code>candle_power</code> and <code>enabled</code> attributes as well as the <code>light()</code> and <code>extinguish()</code> methods.</p>

<p>The <code>+</code> at the start of an attribute name (such as <code>candle_power</code>) indicates that the current class does something special with that attribute. Here the super candle overrides the default value of the light source, so any new <code>SuperCandle</code> created has a light value of 100 regular candles.</p>

<p>When you invoke <code>light()</code> or <code>extinguish()</code> on a <code>SuperCandle</code> object, Perl will look in the <code>SuperCandle</code> class for the method. If there&#39;s no method by that name in the child class, Perl will look at each parent in turn, recursively. In this case, those methods are in the <code>LightSource</code> class.</p>

<p id="TW9vc2U7YXR0cmlidXRlaW5oZXJpdGFuY2U1">Attribute inheritance works similarly (see <code>perldoc Class::MOP</code>).</p>

<h4 id="TWV0aG9kRGlzcGF0Y2hPcmRlcg"><a name="TWV0aG9kRGlzcGF0Y2hPcmRlcg"></a>Method Dispatch Order</h4>

<p id="bWV0aG9kcztyZXNvbHV0aW9u1"> <a name="bWV0aG9kcmVzb2x1dGlvbm9yZGVy1"></a> <a name="bWV0aG9kcztkaXNwYXRjaG9yZGVy1"></a> <a name="bXVsdGlwbGVpbmhlcml0YW5jZQ1"></a> <a name="b2JqZWN0cztpbmhlcml0YW5jZQ1"></a> <a name="b2JqZWN0czttdWx0aXBsZWluaGVyaXRhbmNl1"></a> <a name="TVJP1"></a><a name="ZGlzcGF0Y2g1"></a> <a name="bWV0aG9kZGlzcGF0Y2g1"></a> <a name="T087ZGlzcGF0Y2g1"></a> <a name="T087bWV0aG9kZGlzcGF0Y2g1"></a>A method call always involves a <em>dispatch</em> strategy. This strategy controls how Perl selects the appropriate method. This may seem obvious, given how simple the <code>Cat</code> class is, but much of the power of OO comes from method dispatch.</p>

<p><em>Method dispatch order</em> (or <em>method resolution order</em> or <em>MRO</em>) is obvious for single-parent classes. Look in the object&#39;s class, then its parent, and so on until you find the method or run out of parents. Classes which inherit from multiple parents (<em>multiple inheritance</em>)—<code>Hovercraft</code> extends both <code>Boat</code> and <code>Car</code>—require trickier dispatch. Reasoning about multiple inheritance is complex. Avoid multiple inheritance when possible.</p>

<p>Perl uses a depth-first method resolution strategy. It searches the class of the <em>first</em> named parent and all of that parent&#39;s parents recursively before searching the classes of the current class&#39;s immediate parents. The <code>mro</code> pragma (<a href="08-perl-style-efficiency.html#cHJhZ21hcw">Pragmas</a>) provides alternate strategies, including the C3 MRO strategy which searches a given class&#39;s immediate parents before searching any of their parents.</p>

<p>See <code>perldoc mro</code> for more details.</p>

<h4 id="SW5oZXJpdGFuY2VhbmRNZXRob2Rz"><a name="SW5oZXJpdGFuY2VhbmRNZXRob2Rz"></a>Inheritance and Methods</h4>

<p id="TW9vc2U7b3ZlcnJpZGluZ21ldGhvZHM1"> <a name="TW9vc2U7b3ZlcnJpZGU1"></a>As with attributes, subclasses may override methods. Imagine a light that you cannot extinguish:</p>

<div class="programlisting">

<pre><code>    package Glowstick
    {
        use Moose;

        extends &#39;LightSource&#39;;

        sub extinguish {}
    }</code></pre>

</div>

<p>Calling <code>extinguish()</code> on a glowstick does nothing, even though <code>LightSource</code>&#39;s method does something. Method dispatch will find the subclass&#39;s method. You may not have meant to do this. When you do, use Moose&#39;s <code>override</code> to express your intention clearly.</p>

<p>Within an overridden method, Moose&#39;s <code>super()</code> allows you to call the overridden method:</p>

<div class="programlisting">

<pre><code>    package LightSource::Cranky
    {
        use Carp &#39;carp&#39;;
        use Moose;

        extends &#39;LightSource&#39;;

        <strong>override</strong> light =&gt; sub
        {
            my $self = shift;

            carp &quot;Can&#39;t light a lit light source!&quot;
                if $self-&gt;enabled;

            <strong>super()</strong>;
        };

        <strong>override</strong> extinguish =&gt; sub
        {
            my $self = shift;

            carp &quot;Can&#39;t extinguish unlit light source!&quot;
                unless $self-&gt;enabled;

            <strong>super()</strong>;
        };
    }</code></pre>

</div>

<p>This subclass adds a warning when trying to light or extinguish a light source that already has the current state. The <code>super()</code> function dispatches to the nearest parent&#39;s implementation of the current method, per the normal Perl method resolution order. (See <code>perldoc Moose::Manual::MethodModifiers</code> for more dispatch options.)</p>

<h4 id="SW5oZXJpdGFuY2VhbmRpc2EoKQ"><a name="SW5oZXJpdGFuY2VhbmRpc2EoKQ"></a>Inheritance and isa()</h4>

<p id="aXNhKCk1"> <a name="TW9vc2U7aXNhKCk1"></a>Perl&#39;s <code>isa()</code> method returns true if its invocant is or extends a named class. That invocant may be the name of a class or an instance of an object:</p>

<div class="programlisting">

<pre><code>    say &#39;Looks like a LightSource&#39;
        if $sconce-&gt;isa( &#39;LightSource&#39; );

    say &#39;Hominidae do not glow&#39;
        unless $chimpy-&gt;isa( &#39;LightSource&#39; );</code></pre>

</div>

<h3 id="TW9vc2VhbmRQZXJsT08"><a name="TW9vc2VhbmRQZXJsT08"></a>Moose and Perl OO</h3>

<p id="TW9vc2U7Y29tcGFyZWR0b2RlZmF1bHRQZXJsT081">Moose provides many features beyond Perl&#39;s default OO. While you <em>can</em> build everything you get with Moose yourself (<a href="07-object-oriented-perl.html#Ymxlc3NlZF9yZWZlcmVuY2Vz">Blessed References</a>), or cobble it together with a series of CPAN distributions, Moose is worth using. It is a coherent whole, with good documentation. Many important projects use it successfully. Its development community is mature and attentive.</p>

<p id="bWV0YXByb2dyYW1taW5n1"> <a name="TW9vc2U7TU9Q1"></a> <a name="TW9vc2U7bWV0YXByb2dyYW1taW5n1"></a> <a name="Q2xhc3M6Ok1PUA1"></a> <a name="Q2xhc3M6Ok1PUDo6Q2xhc3M1"></a>Moose takes care of constructors, destructors, accessors, and encapsulation. You must do the work of declaring what you want, but what you get back is safe and easy to use. Moose objects can extend and work with objects from the vanilla Perl system.</p>

<p>Moose also allows <em>metaprogramming</em>—manipulating your objects through Moose itself. If you&#39;ve ever wondered which methods are available on a class or an object or which attributes an object supports, this information is available:</p>

<div class="programlisting">

<pre><code>    my $metaclass = Monkey::Pants-&gt;meta;

    say &#39;Monkey::Pants instances have the attributes:&#39;;

    say $_-&gt;name for $metaclass-&gt;get_all_attributes;

    say &#39;Monkey::Pants instances support the methods:&#39;;

    say $_-&gt;fully_qualified_name
        for $metaclass-&gt;get_all_methods;</code></pre>

</div>

<p>You can even see which classes extend a given class:</p>

<div class="programlisting">

<pre><code>    my $metaclass = Monkey-&gt;meta;

    say &#39;Monkey is the superclass of:&#39;;

    say $_ for $metaclass-&gt;subclasses;</code></pre>

</div>

<p>See <code>perldoc Class::MOP::Class</code> for more information about metaclass operations and <code>perldoc Class::MOP</code> for Moose metaprogramming information.</p>

<p>Moose and its <em>meta-object protocol</em> (or MOP) offers the possibility of a better syntax for declaring and working with classes and objects in Perl. This is valid code:</p>

<div class="programlisting">

<pre><code>    use MooseX::Declare;

    <strong>role</strong> LivingBeing { requires qw( name age diet ) }

    <strong>role</strong> CalculateAge::From::BirthYear { has &#39;birth_year&#39;,
            is      =&gt; &#39;ro&#39;,
            isa     =&gt; &#39;Int&#39;,
            default =&gt; sub { (localtime)[5] + 1900 };

        <strong>method</strong> age
        {
            return (localtime)[5] + 1900
                                  - $self-&gt;birth_year;
        }
    }

    <strong>class Cat with LivingBeing</strong>
              <strong>with CalculateAge::From::BirthYear</strong>
    {
        has &#39;name&#39;, is =&gt; &#39;ro&#39;, isa =&gt; &#39;Str&#39;;
        has &#39;diet&#39;, is =&gt; &#39;rw&#39;;
    }</code></pre>

</div>

<p id="Q1BBTjtNb29zZVg6OkRlY2xhcmU1"> <a name="Q1BBTjtEZXZlbDo6RGVjbGFyZQ1"></a> <a name="Q1BBTjtNb29wcw2"></a> <a name="Q1BBTjtNb29zZVg6Ok1ldGhvZDo6U2lnbmF0dXJlcw3"></a>The <code>MooseX::Declare</code> CPAN distribution uses <code>Devel::Declare</code> to add new Moose-specific syntax. The <code>class</code>, <code>role</code>, and <code>method</code> keywords reduce the amount of boilerplate necessary to write good object oriented code in Perl. Note specifically the declarative nature of this example, as well as the lack of <code>my $self = shift;</code> in <code>age()</code>.</p>

<p>If you&#39;re using a Perl of 5.14 or newer, <code>Devel::Declare</code> is less useful; Perl itself supports a pluggable keyword system. In that case, a syntax-warping module such as <code>MooseX::Method::Signatures</code> or <code>Moops</code> may be more to your taste.</p>

<p>While Moose is not a part of the Perl core, its popularity ensures that it&#39;s available on many OS distributions. Perl distributions such as Strawberry Perl and ActivePerl also include it. Even though Moose is a CPAN module and not a core library, its cleanliness and simplicity make it essential to modern Perl programming.</p>

<div class="tip">
<p class="title">The Svelte <em>Alces</em></p>
<a name="Q1BBTjtNb281"></a><p>Moose isn&#39;t a small library, but it&#39;s powerful. The most popular alternative is <code>Moo</code>, a slimmer library that&#39;s almost completely compatible with Moose. Moo lacks some of the metaprogramming facilities of Moose, but most code doesn&#39;t need them. You can easily start a project with Moo and switch to Moose trivially if and when you need the additional power.</p>

</div><h2 id="Ymxlc3NlZF9yZWZlcmVuY2Vz"><a name="Qmxlc3NlZFJlZmVyZW5jZXM"></a>Blessed References</h2>

<p id="Ymxlc3NlZF9yZWZlcmVuY2Vz">Perl&#39;s core object system is deliberately minimal. It has only three rules:</p>

<ul>

<li>A class is a package.</li>

<li>A method is a function.</li>

<li>A (blessed) reference is an object.</li>

</ul>

<p>You can build anything else out of those three rules. This minimalism can be impractical for larger projects—in particular, the possibilities for greater abstraction through metaprogramming (<a href="09-managing-perl-programs.html#Y29kZV9nZW5lcmF0aW9u">Code Generation</a>) are awkward and limited. Moose (<a href="07-object-oriented-perl.html#bW9vc2U">Moose</a>) is a better choice for modern programs larger than a couple of hundred lines, although lots of legacy code still uses Perl&#39;s default OO.</p>

<p id="T087Ymxlc3M1"> <a name="YnVpbHRpbnM7Ymxlc3M1"></a>You&#39;ve seen the first two rules already. The <code>bless</code> builtin associates the name of a class with a reference. That reference is now a valid invocant, and Perl will perform method dispatch on it, using the associated class.</p>

<p id="T087Y29uc3RydWN0b3Jz1"> <a name="T087Y2xhc3NtZXRob2Rz2"></a> <a name="bWV0aG9kcztjbGFzcw2"></a>A constructor is a method which creates and blesses a reference. By convention, constructors have the name <code>new()</code>, but this is not a requirement. Constructors are also almost always <em>class methods</em>.</p>

<p><code>bless</code> takes two operands, a reference and a class name, and evaluates to the reference. The reference may be any valid reference, empty or not. The class does not have to exist yet. You may even use <code>bless</code> outside of a constructor or a class <span class="footnote">... but you&#39;re violating encapsulation to expose the details of object construction outside of a constructor.</span>. A constructor can be as simple as:</p>

<div class="programlisting">

<pre><code>    sub new
    {
        my $class = shift;
        bless {}, $class;
    }</code></pre>

</div>

<p>By design, this constructor receives the class name as the method&#39;s invocant. You may also hard-code the name of a class, at the expense of flexibility. A parametric constructor allows reuse through inheritance, delegation, or exporting.</p>

<p id="T087aW5zdGFuY2VkYXRh1">The type of reference used is relevant only to how the object stores its own <em>instance data</em>. It has no other effect on the resulting object. Hash references are most common, but you can bless any type of reference:</p>

<div class="programlisting">

<pre><code>    my $array_obj  = bless [],          $class;
    my $scalar_obj = bless \$scalar,    $class;
    my $func_obj   = bless \&amp;some_func, $class;</code></pre>

</div>

<p>Moose classes define object attributes declaratively, but Perl&#39;s default OO is lax. A class representing basketball players which stores jersey number and position might use a constructor like:</p>

<div class="programlisting">

<pre><code>    package Player
    {
        sub new
        {
            my ($class, %attrs) = @_;
            bless \%attrs, $class;
        }
    }</code></pre>

</div>

<p>... and create players with:</p>

<div class="programlisting">

<pre><code>    my $joel   = Player-&gt;new( number =&gt; 10,
                            position =&gt; &#39;center&#39; );

    my $damian = Player-&gt;new( number  =&gt; 0,
                             position =&gt; &#39;guard&#39; );</code></pre>

</div>

<p>The class&#39;s methods can access object attributes as hash elements directly:</p>

<div class="programlisting">

<pre><code>    sub format
    {
        my $self = shift;
        return &#39;#&#39;       . $self-&gt;{number}
             . &#39; plays &#39; . $self-&gt;{position};
    }</code></pre>

</div>

<p>... but so can any other code, so any change to the object&#39;s internal representation may break other code. Accessor methods are safer:</p>

<div class="programlisting">

<pre><code>    sub number   { return shift-&gt;{number}   }
    sub position { return shift-&gt;{position} }</code></pre>

</div>

<p>... and now you&#39;re starting to write yourself what Moose gives you for free. Better yet, Moose encourages people to use accessors instead of direct access by hiding the accessor generation code. Goodbye, temptation.</p>

<h3 id="TWV0aG9kTG9va3VwYW5kSW5oZXJpdGFuY2U"><a name="TWV0aG9kTG9va3VwYW5kSW5oZXJpdGFuY2U"></a>Method Lookup and Inheritance</h3>

<p id="bWV0aG9kZGlzcGF0Y2g2"> <a name="T087bWV0aG9kcw2"></a>Given a blessed reference, a method call of the form:</p>

<div class="programlisting">

<pre><code>    my $number = $joel-&gt;number;</code></pre>

</div>

<p>... looks up the name of the class associated with the blessed reference <code>$joel</code>—in this case, <code>Player</code>. Next, Perl looks for a function <span class="footnote">Remember that Perl makes no distinction between functions in a namespace and methods.</span> named <code>number()</code> in <code>Player</code>. If no such function exists and if <code>Player</code> extends a parent class, Perl looks in the parent class (and so on and so on) until it finds a <code>number()</code>. If Perl finds <code>number()</code>, it calls that method with <code>$joel</code> as an invocant.</p>

<div class="tip">
<p class="title">Keeping Namespaces Clean</p>
<a name="Q1BBTjtuYW1lc3BhY2U6OmF1dG9jbGVhbg1"></a><p>The <code>namespace::autoclean</code> CPAN module can help avoid unintentional collisions between imported functions and methods.</p>

</div><p id="QElTQQ1"> <a name="T087QElTQQ1"></a>Moose provides <code>extends</code> to track inheritance relationships, but Perl uses a package global variable named <code>@ISA</code>. The method dispatcher looks in each class&#39;s <code>@ISA</code> to find the names of its parent classes. If <code>InjuredPlayer</code> extends <code>Player</code>, you might write:</p>

<div class="programlisting">

<pre><code>    package InjuredPlayer
    {
        @InjuredPlayer::ISA = &#39;Player&#39;;
    }</code></pre>

</div>

<p id="cGFyZW50cHJhZ21h1"> <a name="cHJhZ21hcztwYXJlbnQ1"></a>The <code>parent</code> pragma (<a href="08-perl-style-efficiency.html#cHJhZ21hcw">Pragmas</a>) is cleaner <span class="footnote">Older code may use the <code>base</code> pragma, but <code>parent</code> superseded <code>base</code> in Perl 5.10.</span>:</p>

<div class="programlisting">

<pre><code>    package InjuredPlayer
    {
        use parent &#39;Player&#39;;
    }</code></pre>

</div>

<p>Moose has its own metamodel which stores extended inheritance information. This allows Moose to provide additional metaprogramming opportunities.</p>

<p id="bXVsdGlwbGVpbmhlcml0YW5jZQ2"> <a name="T087aW5oZXJpdGFuY2U2"></a>You may inherit from multiple parent classes:</p>

<div class="programlisting">

<pre><code>    package InjuredPlayer;
    {
        use parent qw( Player Hospital::Patient );
    }</code></pre>

</div>

<p>... though the caveats about multiple inheritance and method dispatch complexity apply. Consider instead roles (<a href="07-object-oriented-perl.html#cm9sZXM">Roles</a>) or Moose method modifiers.</p>

<h3 id="QVVUT0xPQUQ"><a name="QVVUT0xPQUQ"></a>AUTOLOAD</h3>

<p id="QVVUT0xPQUQ1"> <a name="T087QVVUT0xPQUQ1"></a> <a name="bWV0aG9kcztBVVRPTE9BRA1"></a>If there is no applicable method in the invocant&#39;s class or any of its superclasses, Perl will next look for an <code>AUTOLOAD()</code> function (<a href="05-perl-functions.html#YXV0b2xvYWQ">AUTOLOAD</a>) in every class according to the selected method resolution order. Perl will invoke any <code>AUTOLOAD()</code> it finds to provide or decline the desired method.</p>

<p><code>AUTOLOAD()</code> makes multiple inheritance much more difficult to understand.</p>

<h3 id="TWV0aG9kT3ZlcnJpZGluZ2FuZFNVUEVS"><a name="TWV0aG9kT3ZlcnJpZGluZ2FuZFNVUEVS"></a>Method Overriding and SUPER</h3>

<p>As with Moose, you may override methods in basic Perl OO. Unlike Moose, Perl provides no mechanism for indicating your <em>intent</em> to override a parent&#39;s method. Worse yet, any function you predeclare, declare, or import into the child class may override a method in the parent class by having the same name. Even if you forget to use the <code>override</code> system of Moose, at least it exists. Basic Perl OO offers no such protection.</p>

<p id="YnVpbHRpbnM7U1VQRVI6Og1">To override a method in a child class, declare a method with the same name as the method in the parent. Within an overridden method, call the parent method with the <code>SUPER::</code> dispatch hint:</p>

<div class="programlisting">

<pre><code>    sub overridden
    {
        my $self = shift;
        warn &#39;Called overridden() in child!&#39;;
        return $self-&gt;SUPER::overridden( @_ );
    }</code></pre>

</div>

<p>The <code>SUPER::</code> prefix to the method name tells the method dispatcher to dispatch to an overridden method of the appropriate name. You can provide your own arguments to the overridden method, but most code reuses <code>@_</code>. Be careful to <code>shift</code> off the invocant if you do.</p>

<div class="tip">
<p class="title">The Brokenness of <code>SUPER::</code></p>
<a name="Q1BBTjtTVVBFUg1"></a><p><code>SUPER::</code> has a confusing misfeature: it dispatches to the parent of the package into which the overridden method was <em>compiled</em>. If you&#39;ve imported this method from another package, Perl will happily dispatch to the <em>wrong</em> parent. The desire for backwards compatibility has kept this misfeature in place. The <code>SUPER</code> module from the CPAN offers a workaround. Moose&#39;s <code>super()</code> does not suffer the same problem.</p>

</div><h3 id="U3RyYXRlZ2llc2ZvckNvcGluZ3dpdGhCbGVzc2VkUmVmZXJlbmNlcw"><a name="U3RyYXRlZ2llc2ZvckNvcGluZ3dpdGhCbGVzc2VkUmVmZXJlbmNlcw"></a>Strategies for Coping with Blessed References</h3>

<p>Blessed references may seem minimal and tricky and confusing. They are. Moose is much easier to use, so use it whenever possible. If you do find yourself maintaining code which uses blessed references, or if you can&#39;t convince your team to use Moose in full yet, you can work around some of the problems of blessed references with discipline.</p>

<ul>

<li>Do not mix functions and methods in the same class.</li>

<li>Use a single <em>.pm</em> file for each class, unless the class is a small, self-contained helper used from a single place.</li>

<li>Follow standards of vanilla Perl OO, such as naming constructors <code>new()</code> and using <code>$self</code> as the invocant name in your documentation.</li>

<li>Use accessor methods pervasively, even within methods in your class. A module such as <code>Class::Accessor</code> helps to avoid repetitive boilerplate.</li>

<li>Avoid <code>AUTOLOAD()</code> where possible. If you <em>must</em> use it, use function forward declarations (<a href="05-perl-functions.html#ZnVuY3Rpb25z">Declaring Functions</a>) to avoid ambiguity.</li>

<li>Expect that someone, somewhere will eventually need to subclass (or delegate to or reimplement the interface of) your classes. Make it easier for them by not assuming details of the internals of your code, by using the two-argument form of <code>bless</code>, and by breaking your classes into the smallest responsible units of code.</li>

<li>Use helper modules such as <code>Role::Tiny</code> to allow better use and reuse.</li>

</ul>

<h2 id="cmVmbGVjdGlvbg"><a name="UmVmbGVjdGlvbg"></a>Reflection</h2>

<p id="Q2xhc3M6OkFjY2Vzc29y1"> <a name="Q1BBTjtSb2xlOjpUaW551"></a><a name="cmVmbGVjdGlvbg"></a><a name="cmVmbGVjdGlvbg1"></a> <a name="aW50cm9zcGVjdGlvbg1"></a><em>Reflection</em> (or <em>introspection</em>) is the process of asking a program about itself as it runs. By treating code as data you can manage code in the same way that you manage data. This is a principle behind code generation (<a href="09-managing-perl-programs.html#Y29kZV9nZW5lcmF0aW9u">Code Generation</a>).</p>

<p id="Q1BBTjtDbGFzczo6TU9Q1">Moose&#39;s <code>Class::MOP</code> (<a href="09-managing-perl-programs.html#Y2xhc3NfbW9w">Class::MOP</a>) simplifies many reflection tasks for object systems. If you use Moose, its metaprogramming system will help you. If not, several other Perl idioms help you inspect and manipulate running programs.</p>

<h3 id="Q2hlY2tpbmd0aGF0YU1vZHVsZUhhc0xvYWRlZA"><a name="Q2hlY2tpbmd0aGF0YU1vZHVsZUhhc0xvYWRlZA"></a>Checking that a Module Has Loaded</h3>

<p id="JUlOQw1">If you know the name of a module, you can check that Perl believes it has loaded that module by looking in the <code>%INC</code> hash. When Perl loads code with <code>use</code> or <code>require</code>, it stores an entry in <code>%INC</code> where the key is the file path of the module to load and the value is the full path on disk to that module. In other words, loading <code>Modern::Perl</code> effectively does:</p>

<div class="programlisting">

<pre><code>    $INC{&#39;Modern/Perl.pm&#39;} =
        &#39;.../lib/site_perl/5.12.1/Modern/Perl.pm&#39;;</code></pre>

</div>

<p>The details of the path will vary depending on your installation. To test that Perl has successfully loaded a module, convert the name of the module into the canonical file form and test for that key&#39;s existence within <code>%INC</code>:</p>

<div class="programlisting">

<pre><code>    sub module_loaded
    {
        (my $modname = shift) =~ s!::!/!g;
        return exists $INC{ $modname . &#39;.pm&#39; };
    }</code></pre>

</div>

<p id="QElOQw1"> <a name="Q1BBTjtUZXN0OjpNb2NrT2JqZWN01"></a> <a name="Q1BBTjtUZXN0OjpNb2NrTW9kdWxl1"></a>As with <code>@INC</code>, any code anywhere may manipulate <code>%INC</code>. Some modules (such as <code>Test::MockObject</code> or <code>Test::MockModule</code>) manipulate <code>%INC</code> for good reasons. Depending on your paranoia level, you may check the path and the expected contents of the package yourself.</p>

<p id="Q1BBTjtDbGFzczo6TG9hZA1">The <code>Class::Load</code> CPAN module&#39;s <code>is_class_loaded()</code> function does all of this for you without making you manipulate <code>%INC</code>.</p>

<h3 id="Q2hlY2tpbmd0aGF0YVBhY2thZ2VFeGlzdHM"><a name="Q2hlY2tpbmd0aGF0YVBhY2thZ2VFeGlzdHM"></a>Checking that a Package Exists</h3>

<p>To check that a package exists somewhere in your program—if some code somewhere has executed a <code>package</code> directive with a given name—check that the package inherits from <code>UNIVERSAL</code>. Anything which extends <code>UNIVERSAL</code> must somehow provide the <code>can()</code> method. If no such package exists, Perl will throw an exception about an invalid invocant, so wrap this call in an <code>eval</code> block:</p>

<div class="programlisting">

<pre><code>    say &quot;$pkg exists&quot; if eval { $pkg-&gt;can( &#39;can&#39; ) };</code></pre>

</div>

<p>An alternate approach is to grovel through Perl&#39;s symbol tables. You&#39;re on your own here.</p>

<h3 id="Q2hlY2tpbmd0aGF0YUNsYXNzRXhpc3Rz"><a name="Q2hlY2tpbmd0aGF0YUNsYXNzRXhpc3Rz"></a>Checking that a Class Exists</h3>

<p>Because Perl makes no strong distinction between packages and classes, the best you can do without Moose is to check that a package of the expected class name exists. You <em>can</em> check that the package <code>can()</code> provide <code>new()</code>, but there is no guarantee that any <code>new()</code> found is either a method or a constructor.</p>

<h3 id="Q2hlY2tpbmdhTW9kdWxlVmVyc2lvbk51bWJlcg"><a name="Q2hlY2tpbmdhTW9kdWxlVmVyc2lvbk51bWJlcg"></a>Checking a Module Version Number</h3>

<p>Modules do not have to provide version numbers, but every package inherits the <code>VERSION()</code> method from the universal parent class <code>UNIVERSAL</code> (<a href="09-managing-perl-programs.html#dW5pdmVyc2Fs">The UNIVERSAL Package</a>):</p>

<div class="programlisting">

<pre><code>    my $version = $module-&gt;VERSION;</code></pre>

</div>

<p><code>VERSION()</code> returns the given module&#39;s version number, if defined. Otherwise it returns <code>undef</code>. If the module does not exist, the method will likewise return <code>undef</code>.</p>

<h3 id="Q2hlY2tpbmd0aGF0YUZ1bmN0aW9uRXhpc3Rz"><a name="Q2hlY2tpbmd0aGF0YUZ1bmN0aW9uRXhpc3Rz"></a>Checking that a Function Exists</h3>

<p>To check whether a function exists in a package, call <code>can()</code> as a class method on the package name:</p>

<div class="programlisting">

<pre><code>    say &quot;$func() exists&quot; if $pkg-&gt;can( $func );</code></pre>

</div>

<p>Perl will throw an exception unless <code>$pkg</code> is a valid invocant; wrap the method call in an <code>eval</code> block if you have any doubts about its validity. Beware that a function implemented in terms of <code>AUTOLOAD()</code> (<a href="05-perl-functions.html#YXV0b2xvYWQ">AUTOLOAD</a>) may report the wrong answer if the function&#39;s package has not predeclared the function or overridden <code>can()</code> correctly. This is a bug in the other package.</p>

<p>Use this technique to determine if a module&#39;s <code>import()</code> has imported a function into the current namespace:</p>

<div class="programlisting">

<pre><code>    say &quot;$func() imported!&quot; if __PACKAGE__-&gt;can( $func );</code></pre>

</div>

<p>As with checking for the existence of a package, you <em>can</em> root around in symbol tables yourself, if you have the patience for it.</p>

<h3 id="Q2hlY2tpbmd0aGF0YU1ldGhvZEV4aXN0cw"><a name="Q2hlY2tpbmd0aGF0YU1ldGhvZEV4aXN0cw"></a>Checking that a Method Exists</h3>

<p>There is no foolproof way for reflection to distinguish between a function or a method.</p>

<h3 id="Um9vdGluZ0Fyb3VuZGluU3ltYm9sVGFibGVz"><a name="Um9vdGluZ0Fyb3VuZGluU3ltYm9sVGFibGVz"></a>Rooting Around in Symbol Tables</h3>

<p id="c3ltYm9sdGFibGVz2"> <a name="dHlwZWdsb2Jz1"></a>A <em>symbol table</em> is a special type of hash where the keys are the names of package global symbols and the values are typeglobs. A <em>typeglob</em> is an internal data structure which can contain any or all of a scalar, an array, a hash, a filehandle, and a function.</p>

<p>Access a symbol table as a hash by appending double-colons to the name of the package. For example, the symbol table for the <code>MonkeyGrinder</code> package is available as <code>%MonkeyGrinder::</code>.</p>

<p>You <em>can</em> test the existence of specific symbol names within a symbol table with the <code>exists</code> operator (or manipulate the symbol table to <em>add</em> or <em>remove</em> symbols, if you like). Yet be aware that certain changes to the Perl core have modified the details of what typeglobs store and when and why.</p>

<p id="Q1BBTjtQYWNrYWdlOjpTdGFzaA1">See the &quot;Symbol Tables&quot; section in <code>perldoc perlmod</code> for more details, then prefer the other techniques in this section for reflection. If you really must manipulate symbol tables and typeglobs, consider using the <code>Package::Stash</code> CPAN module instead.</p>

<h2 id="YWR2YW5jZWRfb28"><a name="QWR2YW5jZWRPT1Blcmw"></a>Advanced OO Perl</h2>

<p id="YWR2YW5jZWRfb28">Creating and using objects in Perl with Moose (<a href="07-object-oriented-perl.html#bW9vc2U">Moose</a>) is easy. <em>Designing</em> good programs is not. You must balance between designing too little and too much. Only practical experience can help you understand the most important design techniques, but several principles can guide you.</p>

<h3 id="RmF2b3JDb21wb3NpdGlvbk92ZXJJbmhlcml0YW5jZQ"><a name="RmF2b3JDb21wb3NpdGlvbk92ZXJJbmhlcml0YW5jZQ"></a>Favor Composition Over Inheritance</h3>

<p id="T086Y29tcG9zaXRpb241"> <a name="T087aW5oZXJpdGFuY2U3"></a>Novice OO designs often overuse inheritance to reuse code and to exploit polymorphism. The result is a deep class hierarchy with responsibilities scattered in the wrong places. Maintaining this code is difficult—who knows where to add or edit behavior? What happens when code in one place conflicts with code declared elsewhere?</p>

<p id="T087aXMtYQ1"> <a name="T087aGFzLWE1"></a>Inheritance is only one of many tools for OO programmers. It&#39;s not always the right tool; it&#39;s often the wrong tool. A <code>Car</code> may extend <code>Vehicle::Wheeled</code> (an <em>is-a relationship</em>), but <code>Car</code> may better <em>contain</em> several <code>Wheel</code> objects as instance attributes (a <em>has-a relationship</em>).</p>

<p>Decomposing complex classes into smaller, focused entities (whether classes or roles) improves encapsulation and reduces the possibility that any one class or role does too much. Smaller, simpler, and better encapsulated entities are easier to understand, test, and maintain.</p>

<h3 id="U2luZ2xlUmVzcG9uc2liaWxpdHlQcmluY2lwbGU"><a name="U2luZ2xlUmVzcG9uc2liaWxpdHlQcmluY2lwbGU"></a>Single Responsibility Principle</h3>

<p id="T087c2luZ2xlcmVzcG9uc2liaWxpdHlwcmluY2lwbGU1">When you design your object system, consider the responsibilities of each entity. For example, an <code>Employee</code> object may represent specific information about a person&#39;s name, contact information, and other personal data, while a <code>Job</code> object may represent business responsibilities. Separating these entities in terms of their responsibilities allows the <code>Employee</code> class to consider only the problem of managing information specific to who the person is and the <code>Job</code> class to represent what the person does. (Two <code>Employee</code>s may have a <code>Job</code>-sharing arrangement, for example, or one <code>Employee</code> may have the CFO and the COO <code>Job</code>s.)</p>

<p>When each class has a single responsibility, you improve the encapsulation of class-specific data and behaviors and reduce coupling between classes.</p>

<h3 id="RG9uJ3RSZXBlYXRZb3Vyc2VsZg"><a name="RG9uJ3RSZXBlYXRZb3Vyc2VsZg"></a>Don&#39;t Repeat Yourself</h3>

<p id="RFJZ1">Complexity and duplication complicate development and maintenance. The <em>DRY</em> principle (Don&#39;t Repeat Yourself) is a reminder to seek out and to eliminate duplication within the system. Duplication exists in data as well as in code. Instead of repeating configuration information, user data, and other artifacts within your system, create a single, canonical representation of that information from which you can generate the other artifacts.</p>

<p>This principle helps to reduce the possibility that important parts of your system will get unsynchronized. It also helps you to find the optimal representation of the system and its data.</p>

<h3 id="TGlza292U3Vic3RpdHV0aW9uUHJpbmNpcGxl"><a name="TGlza292U3Vic3RpdHV0aW9uUHJpbmNpcGxl"></a>Liskov Substitution Principle</h3>

<p id="T087TGlza292U3Vic3RpdHV0aW9uUHJpbmNpcGxl1">The Liskov substitution principle suggests that you should be able to substitute a specialization of a class or a role for the original without violating the API of the original. In other words, an object should be as or more general with regard to what it expects and at least as specific about what it produces as the object it replaces.</p>

<p>Imagine two classes, <code>Dessert</code> and its child class <code>PecanPie</code>. If the classes follow the Liskov substitution principle, you can replace every use of <code>Dessert</code> objects with <code>PecanPie</code> objects in the test suite, and everything should pass <span class="footnote">See Reg Braithwaite&#39;s &quot;IS-STRICTLY-EQUIVALENT-TO-A&quot; for more details, <a class="url" href="http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html">http://weblog.raganwald.com/2008/04/is-strictly-equivalent-to.html</a>.</span>.</p>

<h3 id="Y29lcmNpb25z"><a name="U3VidHlwZXNhbmRDb2VyY2lvbnM"></a>Subtypes and Coercions</h3>

<p id="c3VidHlwZXM"> <a name="Y29lcmNpb25z"></a> <a name="dHlwZXM1"></a> <a name="c3VidHlwZXM1"></a> <a name="Y29lcmNpb242"></a>Moose allows you to declare and use types and extend them through subtypes to form ever more specialized descriptions of what your data represents and how it behaves. These type annotations help verify that the data on which you want to work in specific functions or methods is appropriate and even to specify mechanisms by which to coerce data of one type to data of another type.</p>

<p id="TW9vc2U6OlV0aWw6OlR5cGVDb25zdHJhaW50cw1"> <a name="TW9vc2VYOjpUeXBlcw1"></a>For example, you may wish to allow people to provide dates to a <code>Ledger</code> entry as strings while representing them as <code>DateTime</code> instances internally. You can do this by creating a Date type and adding a coercion from string types. See <code>Moose::Util::TypeConstraints</code> and <code>MooseX::Types</code> for more information.</p>

<h3 id="aW1tdXRhYmlsaXR5"><a name="SW1tdXRhYmlsaXR5"></a>Immutability</h3>

<p id="aW1tdXRhYmlsaXR5"><a name="T087aW1tdXRhYmlsaXR51"></a>OO novices often treat objects as if they were bundles of records which use methods to get and set internal values. This simple technique leads to the unfortunate temptation to spread the object&#39;s responsibilities throughout the entire system.</p>

<p>With a well-designed object, you tell it <em>what to do</em>, not <em>how to do it</em>. As a rule of thumb, if you find yourself accessing object instance data (even through accessor methods) outside of the object itself, you may have too much access to an object&#39;s internals.</p>

<p>You can prevent this inappropriate access by making your objects immutable. Provide the necessary data to their constructors, then disallow any modifications of this information from outside the class. Expose no methods to mutate instance data. Once you&#39;ve constructed such an object, you know it&#39;s always in a valid state. You can never modify its data to put it in an invalid state.</p>

<p>This takes tremendous discipline, but the resulting systems are robust, testable, and maintainable. Some designs go as far as to prohibit the modification of instance data <em>within</em> the class itself, though this is much more difficult to achieve.</p>


        </div>